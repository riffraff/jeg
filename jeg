#!/usr/bin/env ruby
# vim: syntax=ruby ts=2 sts=2 expandtab
#

require 'rubygems'
require 'json'
require 'jsonpath'
require 'optparse'
#
# To get rid of the annoying stack trace on ctrl-C:
trap("INT") { abort }
 
JegVersion = 0.1

def mk_expr(v)
    v = '.'+v if v =~ /^\w/
    v = "$"+v if v =~ /^\./
    v
end
options = {}
OptionParser.new do |opts|
  opts.banner = <<-Banner
    Usage: jeg [options] < file"

    jeg makes JSONPath queries on a JSON stream (line-separated blocks).
    It is designed for quick & dirty work so it assumes things for you.
    For example, if a single simple result comes out of the query it will be printed "bare" 
    while if multiple results are matched they will be presented as json. You can override this with a switch.

    Examples:
      Select a top level field in top struct
        {"text":"babble babble"} | jeg -e $.text => ["babble babble"] 
      The -e option is implicit if none is provided
        {"text":"babble babble"} | jeg $.text => ["babble babble"] 

      Leading '$' ("top") and '.' ("this object") can be omitted
        {"text":"babble babble"} | jeg -e .text => ["babble babble"] 
        {"text":"babble babble"} | jeg -e text => ["babble babble"] 
      Select subfield
        {"results":[{"text":"foo"},{"text":"bar"}]} | jeg -e results.text => []
        {"results":[{"text":"foo"},{"text":"bar"}]} | jeg -e results..text => ["foo","bar"]
      Array access
        {"results":[{"a":"b"},{"a":"d"}]} | jeg -e results[0] => [{"a":"b"}]

      Select a sub field everywhere, most always you want this
        {"result":[{"text":"babble babble"}]} | jeg -e ..text => ["babble babble"]
      So you also have a shortcut
        {"result":[{"text":"babble babble"}]} | jeg -a text => ["babble babble"]

      Select all equal fields in an array element
        {"ary":[[{"name":"joe"}, {"name":"jean"}, {"name":"jane"}],[{"name":"wally"}]]} | jeg -e ary[0]..name => ["joe", "jean", "jane"]
      
      
     See JSONPath specs at  http://goessner.net/articles/JsonPath/ .


   Banner

  opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
    options[:verbose] = v
  end
  opts.on("-a", "--anywhere <json field name>", "Matches a field anywhere") do |v|
    options[:expression] = "$.." + v
  end
  opts.on("-e", "--expression <jsonpath expression>", <<-Eof.strip ) do |v|
      Specify a jsonpath expr, leading '$' or '.' are automatically added
    Eof
    options[:expression] = mk_expr(v)
  end
  opts.on("-x", "--explain", "Shows what jeg is doing to your input and what is the actual expression used") do |v|
    options[:explain] = v
  end
  opts.on("-p", "--pretty-print", "Prints the input objects as pretty ruby") do |v|
    options[:pretty_print] = v
  end
  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end

  # Another typical switch to print the version.
  opts.on_tail("--version", "Show version") do
    puts JegVersion
    exit
  end
end.parse!

def main(options)
  if options.empty?
    options[:expression] = mk_expr(ARGV.shift)
  end
  if options[:pretty_print]
    require 'pp'
  end
  if options[:explain]
    puts "Using path '#{options[:expression]}'"
  end
  ARGF.each do |line|
    begin 
      json = JSON.parse(line)
      if options[:verbose]
        puts line
        puts json
      end
      if options[:pretty_print]
        pp json
      end
      puts JSONPath.lookup(json, options[:expression]).to_json
    rescue JSON::ParserError=>e
      STDERR.puts "Something went wrong parsing:\n#{line}"
      STDERR.puts e.message
    end
  end
end

if __FILE__==$0
  main(options)
end
